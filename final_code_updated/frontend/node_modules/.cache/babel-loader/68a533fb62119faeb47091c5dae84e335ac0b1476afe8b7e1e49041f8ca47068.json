{"ast":null,"code":"import { Buffer } from 'buffer';\nimport { EventEmitter } from 'eventemitter3';\n\n// node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js\nvar WebSocketBrowserImpl = class extends EventEmitter {\n  socket;\n  /** Instantiate a WebSocket class\n  * @constructor\n  * @param {String} address - url to a websocket server\n  * @param {(Object)} options - websocket options\n  * @param {(String|Array)} protocols - a list of protocols\n  * @return {WebSocketBrowserImpl} - returns a WebSocket instance\n  */\n  constructor(address, options, protocols) {\n    super();\n    this.socket = new window.WebSocket(address, protocols);\n    this.socket.onopen = () => this.emit(\"open\");\n    this.socket.onmessage = event => this.emit(\"message\", event.data);\n    this.socket.onerror = error => this.emit(\"error\", error);\n    this.socket.onclose = event => {\n      this.emit(\"close\", event.code, event.reason);\n    };\n  }\n  /**\n  * Sends data through a websocket connection\n  * @method\n  * @param {(String|Object)} data - data to be sent via websocket\n  * @param {Object} optionsOrCallback - ws options\n  * @param {Function} callback - a callback called once the data is sent\n  * @return {Undefined}\n  */\n  send(data, optionsOrCallback, callback) {\n    const cb = callback || optionsOrCallback;\n    try {\n      this.socket.send(data);\n      cb();\n    } catch (error) {\n      cb(error);\n    }\n  }\n  /**\n  * Closes an underlying socket\n  * @method\n  * @param {Number} code - status code explaining why the connection is being closed\n  * @param {String} reason - a description why the connection is closing\n  * @return {Undefined}\n  * @throws {Error}\n  */\n  close(code, reason) {\n    this.socket.close(code, reason);\n  }\n  addEventListener(type, listener, options) {\n    this.socket.addEventListener(type, listener, options);\n  }\n};\nfunction WebSocket(address, options) {\n  return new WebSocketBrowserImpl(address, options);\n}\n\n// src/lib/utils.ts\nvar DefaultDataPack = class {\n  encode(value) {\n    return JSON.stringify(value);\n  }\n  decode(value) {\n    return JSON.parse(value);\n  }\n};\n\n// src/lib/client.ts\nvar CommonClient = class extends EventEmitter {\n  address;\n  rpc_id;\n  queue;\n  options;\n  autoconnect;\n  ready;\n  reconnect;\n  reconnect_timer_id;\n  reconnect_interval;\n  max_reconnects;\n  rest_options;\n  current_reconnects;\n  generate_request_id;\n  socket;\n  webSocketFactory;\n  dataPack;\n  /**\n  * Instantiate a Client class.\n  * @constructor\n  * @param {webSocketFactory} webSocketFactory - factory method for WebSocket\n  * @param {String} address - url to a websocket server\n  * @param {Object} options - ws options object with reconnect parameters\n  * @param {Function} generate_request_id - custom generation request Id\n  * @param {DataPack} dataPack - data pack contains encoder and decoder\n  * @return {CommonClient}\n  */\n  constructor(webSocketFactory) {\n    let address = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"ws://localhost:8080\";\n    let {\n      autoconnect = true,\n      reconnect = true,\n      reconnect_interval = 1e3,\n      max_reconnects = 5,\n      ...rest_options\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let generate_request_id = arguments.length > 3 ? arguments[3] : undefined;\n    let dataPack = arguments.length > 4 ? arguments[4] : undefined;\n    super();\n    this.webSocketFactory = webSocketFactory;\n    this.queue = {};\n    this.rpc_id = 0;\n    this.address = address;\n    this.autoconnect = autoconnect;\n    this.ready = false;\n    this.reconnect = reconnect;\n    this.reconnect_timer_id = void 0;\n    this.reconnect_interval = reconnect_interval;\n    this.max_reconnects = max_reconnects;\n    this.rest_options = rest_options;\n    this.current_reconnects = 0;\n    this.generate_request_id = generate_request_id || (() => typeof this.rpc_id === \"number\" ? ++this.rpc_id : Number(this.rpc_id) + 1);\n    if (!dataPack) this.dataPack = new DefaultDataPack();else this.dataPack = dataPack;\n    if (this.autoconnect) this._connect(this.address, {\n      autoconnect: this.autoconnect,\n      reconnect: this.reconnect,\n      reconnect_interval: this.reconnect_interval,\n      max_reconnects: this.max_reconnects,\n      ...this.rest_options\n    });\n  }\n  /**\n  * Connects to a defined server if not connected already.\n  * @method\n  * @return {Undefined}\n  */\n  connect() {\n    if (this.socket) return;\n    this._connect(this.address, {\n      autoconnect: this.autoconnect,\n      reconnect: this.reconnect,\n      reconnect_interval: this.reconnect_interval,\n      max_reconnects: this.max_reconnects,\n      ...this.rest_options\n    });\n  }\n  /**\n  * Calls a registered RPC method on server.\n  * @method\n  * @param {String} method - RPC method name\n  * @param {Object|Array} params - optional method parameters\n  * @param {Number} timeout - RPC reply timeout value\n  * @param {Object} ws_opts - options passed to ws\n  * @return {Promise}\n  */\n  call(method, params, timeout, ws_opts) {\n    if (!ws_opts && \"object\" === typeof timeout) {\n      ws_opts = timeout;\n      timeout = null;\n    }\n    return new Promise((resolve, reject) => {\n      if (!this.ready) return reject(new Error(\"socket not ready\"));\n      const rpc_id = this.generate_request_id(method, params);\n      const message = {\n        jsonrpc: \"2.0\",\n        method,\n        params: params || void 0,\n        id: rpc_id\n      };\n      this.socket.send(this.dataPack.encode(message), ws_opts, error => {\n        if (error) return reject(error);\n        this.queue[rpc_id] = {\n          promise: [resolve, reject]\n        };\n        if (timeout) {\n          this.queue[rpc_id].timeout = setTimeout(() => {\n            delete this.queue[rpc_id];\n            reject(new Error(\"reply timeout\"));\n          }, timeout);\n        }\n      });\n    });\n  }\n  /**\n  * Logins with the other side of the connection.\n  * @method\n  * @param {Object} params - Login credentials object\n  * @return {Promise}\n  */\n  async login(params) {\n    const resp = await this.call(\"rpc.login\", params);\n    if (!resp) throw new Error(\"authentication failed\");\n    return resp;\n  }\n  /**\n  * Fetches a list of client's methods registered on server.\n  * @method\n  * @return {Array}\n  */\n  async listMethods() {\n    return await this.call(\"__listMethods\");\n  }\n  /**\n  * Sends a JSON-RPC 2.0 notification to server.\n  * @method\n  * @param {String} method - RPC method name\n  * @param {Object} params - optional method parameters\n  * @return {Promise}\n  */\n  notify(method, params) {\n    return new Promise((resolve, reject) => {\n      if (!this.ready) return reject(new Error(\"socket not ready\"));\n      const message = {\n        jsonrpc: \"2.0\",\n        method,\n        params\n      };\n      this.socket.send(this.dataPack.encode(message), error => {\n        if (error) return reject(error);\n        resolve();\n      });\n    });\n  }\n  /**\n  * Subscribes for a defined event.\n  * @method\n  * @param {String|Array} event - event name\n  * @return {Undefined}\n  * @throws {Error}\n  */\n  async subscribe(event) {\n    if (typeof event === \"string\") event = [event];\n    const result = await this.call(\"rpc.on\", event);\n    if (typeof event === \"string\" && result[event] !== \"ok\") throw new Error(\"Failed subscribing to an event '\" + event + \"' with: \" + result[event]);\n    return result;\n  }\n  /**\n  * Unsubscribes from a defined event.\n  * @method\n  * @param {String|Array} event - event name\n  * @return {Undefined}\n  * @throws {Error}\n  */\n  async unsubscribe(event) {\n    if (typeof event === \"string\") event = [event];\n    const result = await this.call(\"rpc.off\", event);\n    if (typeof event === \"string\" && result[event] !== \"ok\") throw new Error(\"Failed unsubscribing from an event with: \" + result);\n    return result;\n  }\n  /**\n  * Closes a WebSocket connection gracefully.\n  * @method\n  * @param {Number} code - socket close code\n  * @param {String} data - optional data to be sent before closing\n  * @return {Undefined}\n  */\n  close(code, data) {\n    this.socket.close(code || 1e3, data);\n  }\n  /**\n  * Enable / disable automatic reconnection.\n  * @method\n  * @param {Boolean} reconnect - enable / disable reconnection\n  * @return {Undefined}\n  */\n  setAutoReconnect(reconnect) {\n    this.reconnect = reconnect;\n  }\n  /**\n  * Set the interval between reconnection attempts.\n  * @method\n  * @param {Number} interval - reconnection interval in milliseconds\n  * @return {Undefined}\n  */\n  setReconnectInterval(interval) {\n    this.reconnect_interval = interval;\n  }\n  /**\n  * Set the maximum number of reconnection attempts.\n  * @method\n  * @param {Number} max_reconnects - maximum reconnection attempts\n  * @return {Undefined}\n  */\n  setMaxReconnects(max_reconnects) {\n    this.max_reconnects = max_reconnects;\n  }\n  /**\n  * Connection/Message handler.\n  * @method\n  * @private\n  * @param {String} address - WebSocket API address\n  * @param {Object} options - ws options object\n  * @return {Undefined}\n  */\n  _connect(address, options) {\n    clearTimeout(this.reconnect_timer_id);\n    this.socket = this.webSocketFactory(address, options);\n    this.socket.addEventListener(\"open\", () => {\n      this.ready = true;\n      this.emit(\"open\");\n      this.current_reconnects = 0;\n    });\n    this.socket.addEventListener(\"message\", _ref => {\n      let {\n        data: message\n      } = _ref;\n      if (message instanceof ArrayBuffer) message = Buffer.from(message).toString();\n      try {\n        message = this.dataPack.decode(message);\n      } catch (error) {\n        return;\n      }\n      if (message.notification && this.listeners(message.notification).length) {\n        if (!Object.keys(message.params).length) return this.emit(message.notification);\n        const args = [message.notification];\n        if (message.params.constructor === Object) args.push(message.params);else for (let i = 0; i < message.params.length; i++) args.push(message.params[i]);\n        return Promise.resolve().then(() => {\n          this.emit.apply(this, args);\n        });\n      }\n      if (!this.queue[message.id]) {\n        if (message.method) {\n          return Promise.resolve().then(() => {\n            this.emit(message.method, message?.params);\n          });\n        }\n        return;\n      }\n      if (\"error\" in message === \"result\" in message) this.queue[message.id].promise[1](new Error('Server response malformed. Response must include either \"result\" or \"error\", but not both.'));\n      if (this.queue[message.id].timeout) clearTimeout(this.queue[message.id].timeout);\n      if (message.error) this.queue[message.id].promise[1](message.error);else this.queue[message.id].promise[0](message.result);\n      delete this.queue[message.id];\n    });\n    this.socket.addEventListener(\"error\", error => this.emit(\"error\", error));\n    this.socket.addEventListener(\"close\", _ref2 => {\n      let {\n        code,\n        reason\n      } = _ref2;\n      if (this.ready) setTimeout(() => this.emit(\"close\", code, reason), 0);\n      this.ready = false;\n      this.socket = void 0;\n      if (code === 1e3) return;\n      this.current_reconnects++;\n      if (this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0)) this.reconnect_timer_id = setTimeout(() => this._connect(address, options), this.reconnect_interval);\n    });\n  }\n};\n\n// src/index.browser.ts\nvar Client = class extends CommonClient {\n  constructor() {\n    let address = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"ws://localhost:8080\";\n    let {\n      autoconnect = true,\n      reconnect = true,\n      reconnect_interval = 1e3,\n      max_reconnects = 5\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let generate_request_id = arguments.length > 2 ? arguments[2] : undefined;\n    super(WebSocket, address, {\n      autoconnect,\n      reconnect,\n      reconnect_interval,\n      max_reconnects\n    }, generate_request_id);\n  }\n};\nexport { Client, CommonClient, DefaultDataPack, WebSocket };\n\n//# sourceMappingURL=index.browser.mjs.map","map":{"version":3,"names":["WebSocketBrowserImpl","EventEmitter","socket","constructor","address","options","protocols","window","WebSocket","onopen","emit","onmessage","event","data","onerror","error","onclose","code","reason","send","optionsOrCallback","callback","cb","close","addEventListener","type","listener","DefaultDataPack","encode","value","JSON","stringify","decode","parse","CommonClient","rpc_id","queue","autoconnect","ready","reconnect","reconnect_timer_id","reconnect_interval","max_reconnects","rest_options","current_reconnects","generate_request_id","webSocketFactory","dataPack","arguments","length","undefined","Number","_connect","connect","call","method","params","timeout","ws_opts","Promise","resolve","reject","Error","message","jsonrpc","id","promise","setTimeout","login","resp","listMethods","notify","subscribe","result","unsubscribe","setAutoReconnect","setReconnectInterval","interval","setMaxReconnects","clearTimeout","_ref","ArrayBuffer","Buffer","from","toString","notification","listeners","Object","keys","args","push","i","then","apply","_ref2","Client"],"sources":["D:\\Jasonpieroni\\frontend\\node_modules\\rpc-websockets\\src\\lib\\client\\websocket.browser.ts","D:\\Jasonpieroni\\frontend\\node_modules\\rpc-websockets\\src\\lib\\utils.ts","D:\\Jasonpieroni\\frontend\\node_modules\\rpc-websockets\\src\\lib\\client.ts","D:\\Jasonpieroni\\frontend\\node_modules\\rpc-websockets\\src\\index.browser.ts"],"sourcesContent":["/**\n * WebSocket implements a browser-side WebSocket specification.\n * @module Client\n */\n\n\"use strict\"\n\nimport { EventEmitter } from \"eventemitter3\"\n\nimport {\n    BrowserWebSocketType,\n    NodeWebSocketType,\n    IWSClientAdditionalOptions,\n} from \"./client.types.js\"\n\nclass WebSocketBrowserImpl extends EventEmitter\n{\n    socket: BrowserWebSocketType\n\n    /** Instantiate a WebSocket class\n   * @constructor\n   * @param {String} address - url to a websocket server\n   * @param {(Object)} options - websocket options\n   * @param {(String|Array)} protocols - a list of protocols\n   * @return {WebSocketBrowserImpl} - returns a WebSocket instance\n   */\n    constructor(address: string, options: {}, protocols?: string | string[])\n    {\n        super()\n\n        this.socket = new window.WebSocket(address, protocols)\n\n        this.socket.onopen = () => this.emit(\"open\")\n        this.socket.onmessage = (event) => this.emit(\"message\", event.data)\n        this.socket.onerror = (error) => this.emit(\"error\", error)\n        this.socket.onclose = (event) =>\n        {\n            this.emit(\"close\", event.code, event.reason)\n        }\n    }\n\n    /**\n   * Sends data through a websocket connection\n   * @method\n   * @param {(String|Object)} data - data to be sent via websocket\n   * @param {Object} optionsOrCallback - ws options\n   * @param {Function} callback - a callback called once the data is sent\n   * @return {Undefined}\n   */\n    send(\n        data: Parameters<BrowserWebSocketType[\"send\"]>[0],\n        optionsOrCallback: (\n      error?: Error\n    ) => void | Parameters<NodeWebSocketType[\"send\"]>[1],\n        callback?: () => void\n    )\n    {\n        const cb = callback || optionsOrCallback\n\n        try\n        {\n            this.socket.send(data)\n            cb()\n        }\n        catch (error)\n        {\n            cb(error)\n        }\n    }\n\n    /**\n   * Closes an underlying socket\n   * @method\n   * @param {Number} code - status code explaining why the connection is being closed\n   * @param {String} reason - a description why the connection is closing\n   * @return {Undefined}\n   * @throws {Error}\n   */\n    close(code?: number, reason?: string)\n    {\n        this.socket.close(code, reason)\n    }\n\n    addEventListener<K extends keyof WebSocketEventMap>(\n        type: K,\n        listener: (ev: WebSocketEventMap[K]) => any,\n        options?: boolean | AddEventListenerOptions\n    ): void\n    {\n        this.socket.addEventListener(type, listener, options)\n    }\n}\n\n/**\n * factory method for common WebSocket instance\n * @method\n * @param {String} address - url to a websocket server\n * @param {(Object)} options - websocket options\n * @return {Undefined}\n */\nexport function WebSocket(\n    address: string,\n    options: IWSClientAdditionalOptions\n)\n{\n    return new WebSocketBrowserImpl(address, options)\n}\n","\"use strict\"\n\nexport interface DataPack<\n  T,\n  R extends string | ArrayBufferLike | Blob | ArrayBufferView\n> {\n  encode(value: T): R;\n  decode(value: R): T;\n}\n\nexport class DefaultDataPack implements DataPack<Object, string>\n{\n    encode(value: Object): string\n    {\n        return JSON.stringify(value)\n    }\n\n    decode(value: string): Object\n    {\n        return JSON.parse(value)\n    }\n}\n","/**\n * \"Client\" wraps \"ws\" or a browser-implemented \"WebSocket\" library\n * according to the environment providing JSON RPC 2.0 support on top.\n * @module Client\n */\n\n\"use strict\"\n\nimport NodeWebSocket from \"ws\"\nimport { EventEmitter } from \"eventemitter3\"\nimport {\n    ICommonWebSocket,\n    IWSClientAdditionalOptions,\n    NodeWebSocketType,\n    ICommonWebSocketFactory,\n} from \"./client/client.types.js\"\n\nimport { DataPack, DefaultDataPack } from \"./utils.js\"\n\ninterface IQueueElement {\n  promise: [\n    Parameters<ConstructorParameters<typeof Promise>[0]>[0],\n    Parameters<ConstructorParameters<typeof Promise>[0]>[1]\n  ];\n  timeout?: ReturnType<typeof setTimeout>;\n}\n\nexport interface IQueue {\n  [x: number | string]: IQueueElement;\n}\n\nexport interface IWSRequestParams {\n  [x: string]: any;\n  [x: number]: any;\n}\n\nexport class CommonClient extends EventEmitter\n{\n    private address: string\n    private rpc_id: number | string\n    private queue: IQueue\n    private options: IWSClientAdditionalOptions & NodeWebSocket.ClientOptions\n    private autoconnect: boolean\n    private ready: boolean\n    private reconnect: boolean\n    private reconnect_timer_id: NodeJS.Timeout\n    private reconnect_interval: number\n    private max_reconnects: number\n    private rest_options: IWSClientAdditionalOptions &\n    NodeWebSocket.ClientOptions\n    private current_reconnects: number\n    private generate_request_id: (\n    method: string,\n    params: object | Array<any>\n  ) => number | string\n    private socket: ICommonWebSocket\n    private webSocketFactory: ICommonWebSocketFactory\n    private dataPack: DataPack<object, string>\n\n    /**\n   * Instantiate a Client class.\n   * @constructor\n   * @param {webSocketFactory} webSocketFactory - factory method for WebSocket\n   * @param {String} address - url to a websocket server\n   * @param {Object} options - ws options object with reconnect parameters\n   * @param {Function} generate_request_id - custom generation request Id\n   * @param {DataPack} dataPack - data pack contains encoder and decoder\n   * @return {CommonClient}\n   */\n    constructor(\n        webSocketFactory: ICommonWebSocketFactory,\n        address = \"ws://localhost:8080\",\n        {\n            autoconnect = true,\n            reconnect = true,\n            reconnect_interval = 1000,\n            max_reconnects = 5,\n            ...rest_options\n        } = {},\n        generate_request_id?: (\n      method: string,\n      params: object | Array<any>\n    ) => number | string,\n        dataPack?: DataPack<object, string>\n    )\n    {\n        super()\n\n        this.webSocketFactory = webSocketFactory\n\n        this.queue = {}\n        this.rpc_id = 0\n\n        this.address = address\n        this.autoconnect = autoconnect\n        this.ready = false\n        this.reconnect = reconnect\n        this.reconnect_timer_id = undefined\n        this.reconnect_interval = reconnect_interval\n        this.max_reconnects = max_reconnects\n        this.rest_options = rest_options\n        this.current_reconnects = 0\n        this.generate_request_id = generate_request_id || (() => typeof this.rpc_id === \"number\"\n            ? ++this.rpc_id\n            : Number(this.rpc_id) + 1)\n\n        if (!dataPack) this.dataPack = new DefaultDataPack()\n        else this.dataPack = dataPack\n\n        if (this.autoconnect)\n            this._connect(this.address, {\n                autoconnect: this.autoconnect,\n                reconnect: this.reconnect,\n                reconnect_interval: this.reconnect_interval,\n                max_reconnects: this.max_reconnects,\n                ...this.rest_options,\n            })\n    }\n\n    /**\n   * Connects to a defined server if not connected already.\n   * @method\n   * @return {Undefined}\n   */\n    connect()\n    {\n        if (this.socket) return\n\n        this._connect(this.address, {\n            autoconnect: this.autoconnect,\n            reconnect: this.reconnect,\n            reconnect_interval: this.reconnect_interval,\n            max_reconnects: this.max_reconnects,\n            ...this.rest_options,\n        })\n    }\n\n    /**\n   * Calls a registered RPC method on server.\n   * @method\n   * @param {String} method - RPC method name\n   * @param {Object|Array} params - optional method parameters\n   * @param {Number} timeout - RPC reply timeout value\n   * @param {Object} ws_opts - options passed to ws\n   * @return {Promise}\n   */\n    call(\n        method: string,\n        params?: IWSRequestParams,\n        timeout?: number,\n        ws_opts?: Parameters<NodeWebSocketType[\"send\"]>[1]\n    )\n    {\n        if (!ws_opts && \"object\" === typeof timeout)\n        {\n            ws_opts = timeout\n            timeout = null\n        }\n\n        return new Promise((resolve, reject) =>\n        {\n            if (!this.ready) return reject(new Error(\"socket not ready\"))\n\n            const rpc_id = this.generate_request_id(method, params)\n\n            const message = {\n                jsonrpc: \"2.0\",\n                method: method,\n                params: params || undefined,\n                id: rpc_id,\n            }\n\n            this.socket.send(this.dataPack.encode(message), ws_opts, (error) =>\n            {\n                if (error) return reject(error)\n\n                this.queue[rpc_id] = { promise: [resolve, reject] }\n\n                if (timeout)\n                {\n                    this.queue[rpc_id].timeout = setTimeout(() =>\n                    {\n                        delete this.queue[rpc_id]\n                        reject(new Error(\"reply timeout\"))\n                    }, timeout)\n                }\n            })\n        })\n    }\n\n    /**\n   * Logins with the other side of the connection.\n   * @method\n   * @param {Object} params - Login credentials object\n   * @return {Promise}\n   */\n    async login(params: IWSRequestParams)\n    {\n        const resp = await this.call(\"rpc.login\", params)\n\n        if (!resp) throw new Error(\"authentication failed\")\n\n        return resp\n    }\n\n    /**\n   * Fetches a list of client's methods registered on server.\n   * @method\n   * @return {Array}\n   */\n    async listMethods()\n    {\n        return await this.call(\"__listMethods\")\n    }\n\n    /**\n   * Sends a JSON-RPC 2.0 notification to server.\n   * @method\n   * @param {String} method - RPC method name\n   * @param {Object} params - optional method parameters\n   * @return {Promise}\n   */\n    notify(method: string, params?: IWSRequestParams)\n    {\n        return new Promise<void>((resolve, reject) =>\n        {\n            if (!this.ready) return reject(new Error(\"socket not ready\"))\n\n            const message = {\n                jsonrpc: \"2.0\",\n                method: method,\n                params,\n            }\n\n            this.socket.send(this.dataPack.encode(message), (error) =>\n            {\n                if (error) return reject(error)\n\n                resolve()\n            })\n        })\n    }\n\n    /**\n   * Subscribes for a defined event.\n   * @method\n   * @param {String|Array} event - event name\n   * @return {Undefined}\n   * @throws {Error}\n   */\n    async subscribe(event: string | Array<string>)\n    {\n        if (typeof event === \"string\") event = [event]\n\n        const result = await this.call(\"rpc.on\", event)\n\n        if (typeof event === \"string\" && result[event] !== \"ok\")\n            throw new Error(\n                \"Failed subscribing to an event '\" + event + \"' with: \" + result[event]\n            )\n\n        return result\n    }\n\n    /**\n   * Unsubscribes from a defined event.\n   * @method\n   * @param {String|Array} event - event name\n   * @return {Undefined}\n   * @throws {Error}\n   */\n    async unsubscribe(event: string | Array<string>)\n    {\n        if (typeof event === \"string\") event = [event]\n\n        const result = await this.call(\"rpc.off\", event)\n\n        if (typeof event === \"string\" && result[event] !== \"ok\")\n            throw new Error(\"Failed unsubscribing from an event with: \" + result)\n\n        return result\n    }\n\n    /**\n   * Closes a WebSocket connection gracefully.\n   * @method\n   * @param {Number} code - socket close code\n   * @param {String} data - optional data to be sent before closing\n   * @return {Undefined}\n   */\n    close(code?: number, data?: string)\n    {\n        this.socket.close(code || 1000, data)\n    }\n\n    /**\n   * Enable / disable automatic reconnection.\n   * @method\n   * @param {Boolean} reconnect - enable / disable reconnection\n   * @return {Undefined}\n   */\n    setAutoReconnect(reconnect: boolean)\n    {\n        this.reconnect = reconnect\n    }\n\n    /**\n   * Set the interval between reconnection attempts.\n   * @method\n   * @param {Number} interval - reconnection interval in milliseconds\n   * @return {Undefined}\n   */\n    setReconnectInterval(interval: number)\n    {\n        this.reconnect_interval = interval\n    }\n\n    /**\n   * Set the maximum number of reconnection attempts.\n   * @method\n   * @param {Number} max_reconnects - maximum reconnection attempts\n   * @return {Undefined}\n   */\n    setMaxReconnects(max_reconnects: number)\n    {\n        this.max_reconnects = max_reconnects\n    }\n\n    /**\n   * Connection/Message handler.\n   * @method\n   * @private\n   * @param {String} address - WebSocket API address\n   * @param {Object} options - ws options object\n   * @return {Undefined}\n   */\n    private _connect(\n        address: string,\n        options: IWSClientAdditionalOptions & NodeWebSocket.ClientOptions\n    )\n    {\n        clearTimeout(this.reconnect_timer_id)\n        this.socket = this.webSocketFactory(address, options)\n\n        this.socket.addEventListener(\"open\", () =>\n        {\n            this.ready = true\n            this.emit(\"open\")\n            this.current_reconnects = 0\n        })\n\n        this.socket.addEventListener(\"message\", ({ data: message }) =>\n        {\n            if (message instanceof ArrayBuffer)\n                message = Buffer.from(message).toString()\n\n            try\n            {\n                message = this.dataPack.decode(message)\n            }\n            catch (error)\n            {\n                return\n            }\n\n            // check if any listeners are attached and forward event\n            if (message.notification && this.listeners(message.notification).length)\n            {\n                if (!Object.keys(message.params).length)\n                    return this.emit(message.notification)\n\n                const args = [message.notification]\n\n                if (message.params.constructor === Object) args.push(message.params)\n                // using for-loop instead of unshift/spread because performance is better\n                else\n                    for (let i = 0; i < message.params.length; i++)\n                        args.push(message.params[i])\n\n                // run as microtask so that pending queue messages are resolved first\n                // eslint-disable-next-line prefer-spread\n                return Promise.resolve().then(() =>\n                {\n                    // eslint-disable-next-line prefer-spread\n                    this.emit.apply(this, args)\n                })\n            }\n\n            if (!this.queue[message.id])\n            {\n                // general JSON RPC 2.0 events\n                if (message.method)\n                {\n                    // run as microtask so that pending queue messages are resolved first\n                    return Promise.resolve().then(() =>\n                    {\n                        this.emit(message.method, message?.params)\n                    })\n                }\n\n                return\n            }\n\n            // reject early since server's response is invalid\n            if (\"error\" in message === \"result\" in message)\n                this.queue[message.id].promise[1](\n                    new Error(\n                        \"Server response malformed. Response must include either \\\"result\\\"\" +\n              \" or \\\"error\\\", but not both.\"\n                    )\n                )\n\n            if (this.queue[message.id].timeout)\n                clearTimeout(this.queue[message.id].timeout)\n\n            if (message.error) this.queue[message.id].promise[1](message.error)\n            else this.queue[message.id].promise[0](message.result)\n\n            delete this.queue[message.id]\n        })\n\n        this.socket.addEventListener(\"error\", (error) => this.emit(\"error\", error))\n\n        this.socket.addEventListener(\"close\", ({ code, reason }) =>\n        {\n            if (this.ready)\n            // Delay close event until internal state is updated\n                setTimeout(() => this.emit(\"close\", code, reason), 0)\n\n            this.ready = false\n            this.socket = undefined\n\n            if (code === 1000) return\n\n            this.current_reconnects++\n\n            if (\n                this.reconnect &&\n        (this.max_reconnects > this.current_reconnects ||\n          this.max_reconnects === 0)\n            )\n                this.reconnect_timer_id = setTimeout(\n                    () => this._connect(address, options),\n                    this.reconnect_interval\n                )\n        })\n    }\n}\n","\"use strict\"\n\nimport { WebSocket } from \"./lib/client/websocket.browser.js\"\nimport { CommonClient } from \"./lib/client.js\"\nimport { IWSClientAdditionalOptions } from \"./lib/client/client.types.js\"\n\nexport class Client extends CommonClient\n{\n    constructor(\n        address = \"ws://localhost:8080\",\n        {\n            autoconnect = true,\n            reconnect = true,\n            reconnect_interval = 1000,\n            max_reconnects = 5,\n        }: IWSClientAdditionalOptions = {},\n        generate_request_id?: (\n      method: string,\n      params: object | Array<any>\n    ) => number | string\n    )\n    {\n        super(\n            WebSocket,\n            address,\n            {\n                autoconnect,\n                reconnect,\n                reconnect_interval,\n                max_reconnects,\n            },\n            generate_request_id\n        )\n    }\n}\n\nexport * from \"./lib/client.js\"\nexport * from \"./lib/client/websocket.browser.js\"\nexport * from \"./lib/client/client.types.js\"\nexport * from \"./lib/utils.js\"\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}